{"version":3,"sources":["unstated.js"],"names":["StateContext","Container","constructor","CONTAINER_DEBUG_CALLBACKS","forEach","cb","setState","updater","callback","Promise","resolve","then","nextState","state","Object","assign","promises","_listeners","map","listener","all","subscribe","fn","push","unsubscribe","filter","f","DUMMY_STATE","Subscribe","Component","unmounted","componentWillUnmount","_unsubscribe","instances","container","onUpdate","_createInstances","containers","Error","safeMap","ContainerItem","instance","get","set","render","props","children","apply","to","Provider","parentMap","childMap","Map","inject","__SUPER_SECRET_CONTAINER_DEBUG_HOOK__"],"mappings":";AA4LC,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,SAAA,EAAA,QAAA,sCAAA,EAAA,QAAA,UAAA,QAAA,eAAA,EA3LD,IAAA,EAAA,QAAA,WACA,EAAA,EAAA,QAAA,2BA0LC,SAAA,EAAA,GAAA,OAAA,GAAA,EAAA,WAAA,EAAA,CAAA,QAAA,GAAA,SAAA,EAAA,EAAA,EAAA,GAAA,OAAA,KAAA,EAAA,OAAA,eAAA,EAAA,EAAA,CAAA,MAAA,EAAA,YAAA,EAAA,cAAA,EAAA,UAAA,IAAA,EAAA,GAAA,EAAA,EAtLD,MAAMA,GAAe,EAAqB,EAAA,SAAA,MAEnC,MAAMC,EAIXC,cAAc,EAAA,KAAA,aAAA,GAFgB,EAAA,KAAA,aAAA,IAG5BC,EAA0BC,QAAQC,GAAMA,EAAG,OAG7CC,SACEC,EACAC,GAEOC,OAAAA,QAAQC,UAAUC,KAAK,KACxBC,IAAAA,EAQAA,GAAa,OALfA,EADqB,mBAAZL,EACGA,EAAQ,KAAKM,OAEbN,GAKZ,YADIC,GAAUA,KAIXK,KAAAA,MAAQC,OAAOC,OAAO,GAAI,KAAKF,MAAOD,GAEvCI,IAAAA,EAAW,KAAKC,WAAWC,IAAIC,GAAYA,KAExCV,OAAAA,QAAQW,IAAIJ,GAAUL,KAAK,KAC5BH,GAAAA,EACKA,OAAAA,QAMfa,UAAUC,GACHL,KAAAA,WAAWM,KAAKD,GAGvBE,YAAYF,GACLL,KAAAA,WAAa,KAAKA,WAAWQ,OAAOC,GAAKA,IAAMJ,IAyIvD,QAAA,UAAA,EAxHD,MAAMK,EAAc,GAEb,MAAMC,UAA8CC,EAApD,UAGL,eAAA,GAAA,SAAA,GACQ,EAAA,KAAA,QAAA,IAC0B,EAAA,KAAA,YAAA,IACtB,EAAA,KAAA,aAAA,GAaS,EAAA,KAAA,WAAA,IACZ,IAAIpB,QAAQC,IACZ,KAAKoB,UAGRpB,IAFKJ,KAAAA,SAASqB,EAAajB,MAdjCqB,uBACOD,KAAAA,WAAY,EACZE,KAAAA,eAGPA,eACOC,KAAAA,UAAU7B,QAAQ8B,IACrBA,EAAUV,YAAY,KAAKW,YAc/BC,iBACElB,EACAmB,GAIInB,GAFCc,KAAAA,eAEO,OAARd,EACI,MAAA,IAAIoB,MACR,+DAIAC,IAAAA,EAAUrB,EACVe,EAAYI,EAAWnB,IAAIsB,IACzBC,IAAAA,EAmBGA,MAhBoB,iBAAlBD,GACPA,aAAyBvC,EAEzBwC,EAAWD,GAEXC,EAAWF,EAAQG,IAAIF,MAGrBC,EAAW,IAAID,EACfD,EAAQI,IAAIH,EAAeC,IAI/BA,EAASjB,YAAY,KAAKW,UAC1BM,EAASpB,UAAU,KAAKc,UAEjBM,IAIFR,OADFA,KAAAA,UAAYA,EACVA,EAGTW,SACE,OAAA,EAAA,EAAA,sBAAA,EAAA,EAAA,SAAA,CAEK1B,SAAAA,GACC,KAAK2B,MAAMC,SAASC,MAClB,KACA,KAAKX,iBAAiBlB,EAAK,KAAK2B,MAAMG,QAa3C,SAASC,EAASJ,GACvB,OAAA,EAAA,EAAA,sBAAA,EAAA,EAAA,SAAA,CAEKK,SAAAA,IACKC,IAAAA,EAAW,IAAIC,IAAIF,GAQvB,OANIL,EAAMQ,QACRR,EAAMQ,OAAOjD,QAAQqC,IACnBU,EAASR,IAAIF,EAASvC,YAAauC,MAIvC,EAAA,EAAA,sBAAA,EAAA,EAAA,SAAA,CACgCU,MAAAA,EAC3BN,SAAAA,EAAMC,cAgBlB,QAAA,UAAA,EARD,IAAI3C,EAA4B,GAIzB,SAASmD,EACd9C,GAEAL,EAA0BoB,KAAKf","file":"unstated.map","sourceRoot":"..\\..\\src","sourcesContent":["// @flow\r\nimport { Component, InfernoChildren } from 'inferno';\r\nimport createInfernoContext from 'create-inferno-context';\r\n\r\ntype Listener = () => mixed;\r\n\r\nconst StateContext = createInfernoContext(null);\r\n\r\nexport class Container<State: {}> {\r\n  state: State;\r\n  _listeners: Array<Listener> = [];\r\n\r\n  constructor() {\r\n    CONTAINER_DEBUG_CALLBACKS.forEach(cb => cb(this));\r\n  }\r\n\r\n  setState(\r\n    updater: $Shape<State> | ((prevState: $Shape<State>) => $Shape<State>),\r\n    callback?: () => void\r\n  ): Promise<void> {\r\n    return Promise.resolve().then(() => {\r\n      let nextState;\r\n\r\n      if (typeof updater === 'function') {\r\n        nextState = updater(this.state);\r\n      } else {\r\n        nextState = updater;\r\n      }\r\n\r\n      if (nextState == null) {\r\n        if (callback) callback();\r\n        return;\r\n      }\r\n\r\n      this.state = Object.assign({}, this.state, nextState);\r\n\r\n      let promises = this._listeners.map(listener => listener());\r\n\r\n      return Promise.all(promises).then(() => {\r\n        if (callback) {\r\n          return callback();\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  subscribe(fn: Listener) {\r\n    this._listeners.push(fn);\r\n  }\r\n\r\n  unsubscribe(fn: Listener) {\r\n    this._listeners = this._listeners.filter(f => f !== fn);\r\n  }\r\n}\r\n\r\nexport type ContainerType = Container<Object>;\r\nexport type ContainersType = Array<Class<ContainerType> | ContainerType>;\r\nexport type ContainerMapType = Map<Class<ContainerType>, ContainerType>;\r\n\r\nexport type SubscribeProps<Containers: ContainersType> = {\r\n  to: Containers,\r\n  children: (\r\n    ...instances: $TupleMap<Containers, <C>(Class<C> | C) => C>\r\n  ) => Object\r\n};\r\n\r\ntype SubscribeState = {};\r\n\r\nconst DUMMY_STATE = {};\r\n\r\nexport class Subscribe<Containers: ContainersType> extends Component<\r\n  SubscribeProps<Containers>,\r\n  SubscribeState\r\n> {\r\n  state = {};\r\n  instances: Array<ContainerType> = [];\r\n  unmounted = false;\r\n\r\n  componentWillUnmount() {\r\n    this.unmounted = true;\r\n    this._unsubscribe();\r\n  }\r\n\r\n  _unsubscribe() {\r\n    this.instances.forEach(container => {\r\n      container.unsubscribe(this.onUpdate);\r\n    });\r\n  }\r\n\r\n  onUpdate: Listener = () => {\r\n    return new Promise(resolve => {\r\n      if (!this.unmounted) {\r\n        this.setState(DUMMY_STATE, resolve);\r\n      } else {\r\n        resolve();\r\n      }\r\n    });\r\n  };\r\n\r\n  _createInstances(\r\n    map: ContainerMapType | null,\r\n    containers: ContainersType\r\n  ): Array<ContainerType> {\r\n    this._unsubscribe();\r\n\r\n    if (map === null) {\r\n      throw new Error(\r\n        'You must wrap your <Subscribe> components with a <Provider>'\r\n      );\r\n    }\r\n\r\n    let safeMap = map;\r\n    let instances = containers.map(ContainerItem => {\r\n      let instance;\r\n\r\n      if (\r\n        typeof ContainerItem === 'object' &&\r\n        ContainerItem instanceof Container\r\n      ) {\r\n        instance = ContainerItem;\r\n      } else {\r\n        instance = safeMap.get(ContainerItem);\r\n\r\n        if (!instance) {\r\n          instance = new ContainerItem();\r\n          safeMap.set(ContainerItem, instance);\r\n        }\r\n      }\r\n\r\n      instance.unsubscribe(this.onUpdate);\r\n      instance.subscribe(this.onUpdate);\r\n\r\n      return instance;\r\n    });\r\n\r\n    this.instances = instances;\r\n    return instances;\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <StateContext.Consumer>\r\n        {map =>\r\n          this.props.children.apply(\r\n            null,\r\n            this._createInstances(map, this.props.to)\r\n          )\r\n        }\r\n      </StateContext.Consumer>\r\n    );\r\n  }\r\n}\r\n\r\nexport type ProviderProps = {\r\n  inject?: Array<ContainerType>,\r\n  children: InfernoChildren\r\n};\r\n\r\nexport function Provider(props: ProviderProps) {\r\n  return (\r\n    <StateContext.Consumer>\r\n      {parentMap => {\r\n        let childMap = new Map(parentMap);\r\n\r\n        if (props.inject) {\r\n          props.inject.forEach(instance => {\r\n            childMap.set(instance.constructor, instance);\r\n          });\r\n        }\r\n\r\n        return (\r\n          <StateContext.Provider value={childMap}>\r\n            {props.children}\r\n          </StateContext.Provider>\r\n        );\r\n      }}\r\n    </StateContext.Consumer>\r\n  );\r\n}\r\n\r\nlet CONTAINER_DEBUG_CALLBACKS = [];\r\n\r\n// If your name isn't Sindre, this is not for you.\r\n// I might ruin your day suddenly if you depend on this without talking to me.\r\nexport function __SUPER_SECRET_CONTAINER_DEBUG_HOOK__(\r\n  callback: (container: Container<any>) => mixed\r\n) {\r\n  CONTAINER_DEBUG_CALLBACKS.push(callback);\r\n}\r\n"]}